<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste TTS Streaming Real</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        .status.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Teste TTS Streaming Real</h1>
        <p>Este teste verifica se o TTS come√ßa a tocar assim que os primeiros chunks de √°udio chegam.</p>

        <div class="test-section">
            <h3>Teste 1: Streaming Real com MediaSource</h3>
            <button id="testStreaming" onclick="testStreamingTTS()">Testar Streaming Real</button>
            <button id="stopTest" onclick="stopTest()" disabled>Parar Teste</button>
            <div id="streamingStatus" class="status" style="display: none;"></div>
            <div id="streamingLog" class="log" style="display: none;"></div>
        </div>

        <div class="test-section">
            <h3>Teste 2: Compara√ß√£o - Buffered vs Streaming</h3>
            <button onclick="testBufferedTTS()">Testar Modo Buffered (Antigo)</button>
            <button onclick="testStreamingTTS()">Testar Modo Streaming (Novo)</button>
            <div id="comparisonResults"></div>
        </div>
    </div>

    <script>
        let currentTest = null;
        let startTime = null;

        function log(message, elementId = 'streamingLog') {
            const logElement = document.getElementById(elementId);
            if (logElement) {
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
            console.log(message);
        }

        function showStatus(message, type = 'loading', elementId = 'streamingStatus') {
            const statusElement = document.getElementById(elementId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
                statusElement.style.display = 'block';
            }
        }

        async function testStreamingTTS() {
            const testButton = document.getElementById('testStreaming');
            const stopButton = document.getElementById('stopTest');
            const logElement = document.getElementById('streamingLog');
            
            testButton.disabled = true;
            stopButton.disabled = false;
            logElement.style.display = 'block';
            logElement.innerHTML = '';
            
            showStatus('Iniciando teste de streaming real...', 'loading');
            startTime = Date.now();
            
            try {
                log('üé§ Iniciando teste de streaming TTS...');
                
                const response = await fetch('/api/tts/gemini-native', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: 'Este √© um teste de streaming em tempo real. O √°udio deve come√ßar a tocar assim que os primeiros chunks chegarem.',
                        voice: 'Zephyr',
                        speed: 1.0,
                        pitch: 0.0
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                log('‚úÖ Conex√£o estabelecida, iniciando leitura do stream...');
                showStatus('Conectado! Lendo stream...', 'loading');

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let chunkCount = 0;
                let audioChunks = 0;
                let firstAudioTime = null;
                let playbackStarted = false;

                // Set up MediaSource for real-time streaming
                let mediaSource = null;
                let sourceBuffer = null;
                let audio = null;

                try {
                    if ('MediaSource' in window) {
                        mediaSource = new MediaSource();
                        const url = URL.createObjectURL(mediaSource);
                        
                        audio = new Audio();
                        audio.src = url;
                        audio.controls = true;
                        document.body.appendChild(audio);

                        mediaSource.addEventListener('sourceopen', () => {
                            log('üéµ MediaSource aberto');
                            if (mediaSource && mediaSource.readyState === 'open') {
                                sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');
                                log('üéµ SourceBuffer criado');
                            }
                        });

                        audio.addEventListener('play', () => {
                            if (!playbackStarted) {
                                playbackStarted = true;
                                const timeToFirstPlay = Date.now() - startTime;
                                log(`üéµ REPRODU√á√ÉO INICIADA! Tempo: ${timeToFirstPlay}ms`);
                                showStatus(`‚úÖ Streaming funcionando! Primeiro √°udio em ${timeToFirstPlay}ms`, 'success');
                            }
                        });
                    }
                } catch (e) {
                    log('‚ö†Ô∏è MediaSource n√£o suportado, usando fallback');
                }

                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        log('‚úÖ Stream completo');
                        break;
                    }

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                chunkCount++;
                                
                                if (data.type === 'audio' && data.data) {
                                    audioChunks++;
                                    if (!firstAudioTime) {
                                        firstAudioTime = Date.now();
                                        const timeToFirstChunk = firstAudioTime - startTime;
                                        log(`üéµ PRIMEIRO CHUNK DE √ÅUDIO! Tempo: ${timeToFirstChunk}ms`);
                                    }
                                    
                                    // Try real-time streaming
                                    if (sourceBuffer && !sourceBuffer.updating) {
                                        try {
                                            const binaryString = atob(data.data);
                                            const audioData = new Uint8Array(binaryString.length);
                                            for (let i = 0; i < binaryString.length; i++) {
                                                audioData[i] = binaryString.charCodeAt(i);
                                            }
                                            
                                            sourceBuffer.appendBuffer(audioData);
                                            log(`üéµ Chunk ${audioChunks} enviado para SourceBuffer`);
                                            
                                            // Start playing on first chunk
                                            if (!playbackStarted && audio) {
                                                audio.play().catch(e => log(`‚ùå Erro ao iniciar reprodu√ß√£o: ${e.message}`));
                                            }
                                        } catch (e) {
                                            log(`‚ö†Ô∏è Erro no SourceBuffer: ${e.message}`);
                                        }
                                    }
                                } else if (data.type === 'done') {
                                    log('‚úÖ Sinal de conclus√£o recebido');
                                    if (mediaSource && mediaSource.readyState === 'open') {
                                        mediaSource.endOfStream();
                                    }
                                } else if (data.type === 'error') {
                                    log(`‚ùå Erro no stream: ${data.content}`);
                                }
                            } catch (e) {
                                log(`‚ö†Ô∏è Erro ao processar chunk: ${e.message}`);
                            }
                        }
                    }
                }

                const totalTime = Date.now() - startTime;
                log(`üìä Teste conclu√≠do em ${totalTime}ms`);
                log(`üìä Total de chunks: ${chunkCount}, Chunks de √°udio: ${audioChunks}`);

                if (playbackStarted) {
                    showStatus(`‚úÖ Streaming real funcionando! Primeiro √°udio em ${firstAudioTime - startTime}ms`, 'success');
                } else {
                    showStatus('‚ö†Ô∏è Streaming n√£o iniciou automaticamente', 'error');
                }

            } catch (error) {
                log(`‚ùå Erro no teste: ${error.message}`);
                showStatus(`‚ùå Erro: ${error.message}`, 'error');
            } finally {
                testButton.disabled = false;
                stopButton.disabled = true;
            }
        }

        function stopTest() {
            if (currentTest) {
                currentTest.abort();
                currentTest = null;
            }
            
            // Remove audio elements
            const audios = document.querySelectorAll('audio');
            audios.forEach(audio => audio.remove());
            
            document.getElementById('testStreaming').disabled = false;
            document.getElementById('stopTest').disabled = true;
            showStatus('Teste interrompido', 'error');
        }

        async function testBufferedTTS() {
            showStatus('Testando modo buffered (antigo)...', 'loading');
            const startTime = Date.now();
            
            try {
                const response = await fetch('/api/tts/gemini-native', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: 'Teste do modo buffered - aguarda todo o √°udio carregar antes de tocar.',
                        voice: 'Zephyr'
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let audioChunks = [];
                let firstChunkTime = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));
                            if (data.type === 'audio' && data.data) {
                                if (!firstChunkTime) {
                                    firstChunkTime = Date.now();
                                }
                                const binaryString = atob(data.data);
                                const audioData = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    audioData[i] = binaryString.charCodeAt(i);
                                }
                                audioChunks.push(audioData);
                            }
                        }
                    }
                }

                // Combine and play
                const totalLength = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combinedAudio = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of audioChunks) {
                    combinedAudio.set(chunk, offset);
                    offset += chunk.length;
                }

                const audioBlob = new Blob([combinedAudio], { type: 'audio/mpeg' });
                const url = URL.createObjectURL(audioBlob);
                const audio = new Audio(url);
                audio.controls = true;
                document.body.appendChild(audio);

                const timeToPlay = Date.now() - startTime;
                showStatus(`‚úÖ Modo buffered: ${timeToPlay}ms para come√ßar a tocar`, 'success');
                
            } catch (error) {
                showStatus(`‚ùå Erro no teste buffered: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
